# 绘制上下文

绘制上下文是指在你的应用上通过一个虚拟的画布进行绘制。在本章，你需要复习iOS绘图的核心技术。深入理解上下文，才能知道如创建和绘制他们。通过学习UIKit，Core Graphics 和 Quartz中的绘图基础，使用上下文来创建图片，文档和子视图。
### 框架
iOS绘图程序主要基于UIKit和QuartzCore框架，它由新颖的Objective-C界面（UIKit提供）和老旧一些的C语言方法和核心基础类（QuartzCore）组成。两者共同完整了你的代码。这里有一个例子分别展示了UIKit绘制和Quartz绘制：
```
//Draw a rounded rectangle in UIKit
UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRoundedRect:inset cornerRadius:12];
[bezierPath stroke];

//Fill an ellipse in Quartz
CGContextFillEllipseInRect(context, rect);
```
QuertzCore框架通常被称作Quartz或者Quartz 2D。后者是苹果官方命名，因为它原本是2D图形的API。他最初命名在苹果的开发者文档“Quartz 2D Programming Guide”。

这个框架实际涉及到的地方比Quartz 2D这个名字暗示的要广。QuartzCore引用混合和使用很多其他图片特征。比如说，Quartz API包括了动画， 贴片，以及Core Image 过滤（尽管Core Image有它自己完整的框架）

对于iOS开发者来说，Quartz往往比它的内部名字Core Graphics更加出名。本书使用Quartz或者Core Graphics都是表示一个意思。大多数以CG开头的C语言API都是指的Core Graphics。从几何（CGRect和CGPoint）到对象（CGColorRef，CGImageRef和CGDataProviderRef）。Quartz提供了极其广袤的绘图技术。

Quartz和他的前辈已经很好的被使用了很长一段时间，可以一直追溯到20世纪80年代，在Display PostScript在NeXTStep操作系统中加强了图像时。然而，Core Graphics方法仍然持续在绘图开发中日复一日的发挥着重要的作用。尽管更新的程序替代了一些常用任务，但他们并未被完全取代掉。准备好在未来同这些框架一起工作吧。
### 何时绘制？
尽管iOS绘图对于开发者来说是完全一样的任务， 但任务本身可能不尽相同。大部分绘制会限制在特定的场地，有四个直接对图像有意义的部分使用极其相似的脚本（注：这句可能翻译有问题）：创建子视图，构造图片，创建PDF以及构造核心图像。

#### 创建子视图

每一个UIKit视图实际上都是一个空白的画布。你可以完全地自定义一个视图通过绘制一些你想要在应用中表达的内容。你可以通过一个很特别的方法 -drawRect：来完成。 该方法允许你通过一些UIKit和Quartz Drawing代码来自定义视图的外貌。

<img src="./1-1.png" alt="图1.1" title="图1.1" width="700"/>

图1-1 展示了一个自定义的颜色选择器。他包括了一组选择视图，每一个视图都是UIView通过drawRect：绘制的子视图。这些视图绘制了圆角，文本信息和一个色块。

除非你重用于一个子类，否者默认drawRect：是什么都不干的。子类想要通过UIKit和Core Graphics代码来创建控价外貌需要重用drawRect：方法，它添加了绘制请求来实现子类。简单的视图比如只更新背景颜色或是通过其他方法改变类容而非绘制的不应该重写drawRect：。同样地，OpenGL ES视图也不以此为绘图的接入点。

drawRect：方法有一个近亲-drawRect：forViewPrintFormatter：允许你子类化的绘制类容和展示不同（注：可能翻译有误）。

#### 构造图片

并不是每个图片一开始都是一张PNG或者一张JPEG。在iOS中，你可以绘制一个UIKit图片上下文，再把他转换为一个UIImage实例。这可以帮助你创建一张新图片，或是处理一些已存在的图片。

图1-2展示了一个代码创建的颜色选择轮盘，这个图片通过一系列的贝塞尔曲线圆弧绘制到一个UIKit图像的上下文中创建。处理的结果图片被添加到了一个标准的图片视图中，绘制允许你创建一个自定义的图片，而不用事先保存在文件目录中。
以代码为基础的绘制是一个很重要的折衷的办法。尽管你需要跟多的时间来创建图片（并不需要很大量的代码，而且是可以测量的），但是你可以得到一个很小的程序包，因为有很少的资源文件。你的图片也更加灵活——仅需改变创建他们的代码即可。

<img src="./1-2.png" alt="图1.2" title="图1.2" width="700"/>


#### 创建PDF

和创建图片类似的方法也支持PDF的创建，你可以绘制在一个UIKit PDF上下文中，不需要直接发送到文件或是数据。它可以帮助你在应用中创建PDF上下文并分享，存储或是展示他们，就像图1-3那样。
PDF提供一个高度的可分割的，系统独立标准封装了一个完成的文档描述。这个文档你在iOS中创建的会和你在其他电脑看到的或多或少地一样。操作系统的颜色管理系统也许会影响到颜色的展示
图1-3展示了一个在Popover的视图中多页PDF

<img src="./1-3.png" alt="图1.3" title="图1.3" width="700"/>


#### 构造核心图像
当你碰触到现在UIKit的性能极限，你可能需要转而向标准的Quartz求助。Core Graphics一直处于领先地位，它的绘制能力在OS X已经高效使用了近十年了。任何在UIKit中不能马上调节的特征，都机会可以通过Quartz实现。
Core Graphics上下文的绘制组件提供了灵活有力的绘图解决方案——哪怕那不如它的兄弟UIKit那样简单。Core Graphics 使用核心基础风格的C语言基础的对象并且需要手动管理内存。
比如说，你也许想要一字节一字节地处理图像。这个任务在UIKit好像不能很好的完成，但是使用Core Graphics的位图上下文却能够很好的被解决。图1-4展示了一个例子解释了为什么需要使用一些Quartz的特性。在这个例子中，左侧的RGB图像通过Core Graphics转换成了一个灰度图像。
得到的灰度图是通过Quartz的CGImageRef（以CG开头Ref结尾的类型是指，指向对象的指针）转换成UIImage实例（imageWithCGImage：），再通过图片视图展示出来的。

<img src="./1-4.png" alt="图1.4" title="图1.4" width="700"/>



### 上下文 Contexts

所有的iOS绘图操作都是从一个上下文开始的。从概念上来说，上下文非常类似于一页空纸或是一张空的画布。它们展示iOS绘图的目的地。它们囊括了所有绘图界质状态所包含的信息——比如说，无论画布旋转或是位移，画布上绘制何种颜色，你可以绘制在图片上的点的细节程度都是如此的（注：可能有误，这句好难啊🤯）
在iOS中，你主要会和两种上下文打交道：位图上下文和PDF上下文。Core Image框架海提供了第三种上下文类型，用来处理图片进程任务而非绘图。

#### 位图上下文

位图上下文基本上是矩形数据数组。数据的大小取决于图片的每一个元素（或像素）展示何种类型的颜色。Device RGB——就像图1-4的左侧图片——需要用到3或4字节每个像素。透明图象需要4个字节，不透明图象3个字节。
为了优化存储，不透明位图不需理会透明值。透明图象多了一个alpha值。这个值存储在实际颜色和亮度中一个很特别的字节里。他反应了每个像素的透明度。颜色信息在Device RGB图片中存于3个字节中，分别对应了红，绿，蓝的数值。
Device Gray 图像——如图1-4右侧所示——需要用到1或2字节每个像素。其中，亮度信息占一个字节，还有一个是透明度的可选字节。

#### PDF上下文

从开发者的角度来看，PDF上下文和位图上下文的运行方式相似。你通过相同的指令和方法绘制它们。你设置颜色，绘制形状和文本就像你在绘制一个视图或图像一样。然而，它们还是有不同的地方的。
PDF上下文在他的“后备存储”中包括了矢量数据，用来描述绘制在一个分辨率无关的方法中。位图是光栅化的（注：也可以叫点阵化），它使用像素数组来存储和绘制数据。
PDF上下文也可以多于一页。你设置一个边界矩形，限定默认尺寸和每一页的位置。一个空矩形（CGRectZero）默认是一个标准的A（字母）页——8.5x11英尺，或是612x792点（第二章回详细讨论点和像素的区别）。
PDF内部是由向量指令集储存的。他提供了在位图绘制中看不到的与分辨率无关的解决方案。苹果在文档中写道，“PDF文件是天生与分辨率无关的——它们绘制的尺寸可以增加或减少却不需要额外的牺牲图片的细节。用户感知位图图像的质量是通过视图可见部分的分辨率来决定的。”
总的来说，位图上下文和PDF上下文还是大致相似的。区别仅在于目的地（文件和数据的展示）和当你需要翻页时体现。
除了位图上下文和PDF上下文，你也可能会遇到核心图形上下文。

#### Core Image上下文

Core Image框架帮助你快速的处理图片。它提供相关代码来进行数码图片的处理和电脑维护图片资源。有了它，你可以处理滤镜，链型滤镜，进行特征检测（人脸识别），分析图片自适应。
Core Image上下文把Core Image对象和Quartz 2D以及OpenGL紧密联系在一起。得利于移动端图片处理中心（GPU）的发展，核心图形上下文整合了Core Video的像素缓冲区。Core Image使用它自己的颜色和图片类（CIColor和CIImage），它们最好的优化了核心图形的快速滤镜和图片特征检测。

### 在UIKit中创建上下文
UIKit提供了很友好的处理上下文的入口，最简单的图片绘制方法在下方代码1-1中展示。这个代码只展示了开启一个新的上下文（为上下文赋予一个尺寸），绘制，取到一个新的图片，结束这个上下文。这段代码生产出一个1:1比例的图片，所有的复合精确像素的位图上下文绘制操作都在这里进行。

```
UIGraphicsBeginImageContext(size);

//Perform drawing here

UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

```
#### 设备比例

下列代码1-2展示了一个更加常见的（更有效的）入口。它帮助你根据屏幕比例来处理图片。options参数帮助你根据不同设备比例来绘制图片。Scale是指逻辑空间（以点计算）和物理展示（以像素计算）之间的关系。

Scale为2的图片会产生一个Retina图像。像素值在每个方向均为两倍，生成的图片也会以4倍的空间储存相比于scale为1的图片来说。不透明参数(isOpaque)允许你忽略alpha通道以达到最优储存。你只需要3字节每像素即可储存一个不透明图象，而非4字节还有一个额外的alpha通道。

```
UIGraphicsBeginImageContextWithOptions(targetSize,isOpaque,deviceScale);

//Perform drawing here

UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

```
强烈建议你使用上面的代码来创建上下文。比如说，你想为UIImageView绘制一个图片的时候，总是会需要带上options参数的。
你可以通过UIScreen来获取第三个参数。图片绘制在初始屏幕上时，可以使用mainScreen，如下：

```
UIGraphicsBeginImageContextWithOptions(targetSize,isOpaque,[UIScreen mainScreen].scale);
```
当然你可以把第三个参数设置为0.0。系统会自动让比例基于你的主屏。
当作用于视频输出时，有时候你可能会有一个额外的监视器来连接到iOS设备，或是当你使用AirPlay无线展示到另一个屏幕上时，需要设计新设备的特殊scale参数。你同样可以通过UIScreen查询到这些信息。

#### 创建PDF上下文
在创建PDF时，你要么提供一个文件路径要么提供一个提供数据源的可变数据对象。代码1-3展示了
构建的例子。你提供了一个矩形（CGRectZero表示A尺寸的页面）和一个指明元数据的字典，以及新文档的安全信息，比如你也许会需要指明作者，拥有者和密码，印刷和复杂的限制，关键词等等。
和位图上下文一样，Core Graphics的成就（尤其是CGPDFContext）远比UIKit要悠久得多。如果你想钻研C语言基础的类或方法，你将会发现另一套PDF的产品。

```
UIGraphicsBeginPDFContextToFile(pathToFile, theBounds, documentInfo);
UIGraphicsBeginPDFPage();

//perform drawing here

UIGraphicsEndPDFContext();
```

每一页的绘制都需要调用UIGraphicsBeginPDFPage（）方法，他在文档中提供新的一页给你来写入。当你完成输出之后，你不需要明确地结束每一页，但是你必须结束PDF上下文，就像你结束其他的上下文那样。

### 在Quartz中创建上下文

Core Graphics允许你不通过UIKit入口创建位图上下文。这个方法使用更久远的API，他能有效地帮助你一字节一字节地处理绘制数据。第三章会通过使用很多有效的增强图片进程的例子通过Quartz代码。
代码1-4展示更为复杂一些的代码。相比于UIKit，可能更容易让开发者感到困扰。这是因为，Quartz使用旧风格的核心框架对象，还需要手动管理内存。
在使用Quartz代码时记得常常使用静态分析器（Product > Analyze），以便检测你的引用是否正常释放。他提供了代码分析工具，可以同时检测出UIKit方法和Quartz函数中的潜在bug。了解更多：http://clang-analyzer.llvm.org
代码1-4，需注意释放方法。如果上下文不能被创建，color space就必须被释放。在Core Graphic的每个绘制阶段，你都会为很多对象分配内存，你必须在函数或方法结束之前很好的管理它们。
最后一点，要注意如何使用kCGImageAlphaPremultipliedFirst。他提供了一个ARGB序列，使用友好Quartz的前置乘法（注：？）。每一个像素，alpha值都存储在这四个字节里的最前面而蓝色值在最后。这种结构是在CGImage.h中的CGImageAlphaInfo文档中定义的。

```
//create a color space
CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
if(colorSpace == NULl)
{
     NSLog(@"Error allocating color space");
     return nil;
}
//create the bitmap context,(Note: in new version of
//Xcode, you need to cast the alpha setting.)
CGContextRef context = CGBitmapContextCreate(
               NULL,width,height,
               BITS_PER_COMPONENT,
               width * ARGB_COUNT,
               colorSpace,
               (CGBitmapInfo)kCGImageAlphaPremultipliedFirst);
if(context == NULL)
{
     NSLog(@"Error:Context not created!");
     CGColorSpaceRelease(colorSpace);
     return nil;
}

//Push the context;
//(This is optional. Read on for an explanation of this.)
//UIGraphicsPushContext(context);

//Perform drawing here

//Balance the context push if used.
//UIGraphicsPopContext();

//Convert to image
CGImageRef imageRef = CGBitmapContextCreateImage(context);
UIImage *image = [UIImage imageWithCGImage:imageRef];

//clean up
CGColorSpaceRelease(colorSpace);
CGContextRelease(context);
CFRelease(imageRef);
```
### 在上下文中绘图
很多Quartz方法都依赖于你要绘制在上面的上下文。比如说，思考一下代码1-5中的方法，他设置了一个4像素宽，灰色，在一个矩形画布中划出一个椭圆。每个方法都带着一个CGContextRef类型的context参数，你可以自己创建上下文（如代码1-4那样）可以借助UIKit方法，这个我们下一节来探究。
```
//set the line width
CGContextSetLineWidth(context,4);

//set the line color
CGContextSetStrokeColorWithColor(context, [UIColor grayColor].CGColor);

//Draw an ellipse
CGContextStrokeEllipseInRect(context, rect);
```
